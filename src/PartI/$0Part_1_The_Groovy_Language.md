# Part 1. The Groovy language

#### A good notation has subtlety and suggestiveness which at times makes it almost seem like a live teacher.

<b>Bertrand Russell The World of Mathematics (1956)</b>

Learning a new programming language is comparable to learning to speak a foreign language. You have to deal with new 
vocabulary, grammar, and language idioms. But this initial effort pays off multiple times. With the new language, you 
find unique ways to express yourself, you’re exposed to new concepts and styles that add to your personal abilities,
and you may even explore new perspectives on your world. This is what Groovy did for us, and we hope Groovy will do 
it for you, too.

The first part of this book introduces you to the language basics: the Groovy syntax, grammar, and typical idioms. 
We present the language by example as opposed to using an academic style.

You may skim this part on first read and revisit it before going into serious development with Groovy. If you decide 
to skim, please make sure you visit chapter 2 and its examples. They are cross-linked to the in-depth chapters so you 
can easily look up details about any topic that interests you.

One of the difficulties of explaining a programming language by example is that you have to start somewhere. No matter 
where you start, you end up needing to use some concept or feature that you haven’t explained yet for your examples. 
Section 2.3 serves to resolve this perceived deadlock by providing a collection of self-explanatory warm-up examples.

We explain the main portion of the language using its built-in datatypes and introduce expressions, operators, and 
keywords as we go along. By starting with some of the most familiar aspects of the language and building up your 
knowledge in stages, we hope you’ll always feel confident when exploring new territory.

Chapter 3 introduces Groovy’s practical approach to typing, examines the numeric and other primitive types that Groovy 
supports, and discusses strings and regular expressions.

Chapter 4 continues looking at Groovy’s rich set of built-in types, examining those with a collection-like nature: 
ranges, lists, and maps.

Chapter 5 builds on the preceding sections and provides an in-depth description of the closure concept.

Chapter 6 touches on logical branching, looping, and shortcutting program execution flow.

Chapter 7 sheds light on the way Groovy builds on Java’s object-oriented features adding support for multimethods 
and traits.

Chapter 8 looks at Groovy’s dynamic programming capabilities.

Chapter 9 dives into compile-time metaprogramming and AST transformations.

Chapter 10, the final chapter in part 1, discusses Groovy as a static language.

At the end of part 1, you’ll have the whole picture of the Groovy language. This is the basis for getting the most out 
of part 2, which explores the Groovy library: the classes and methods that Groovy adds to the Java platform. Part 3, 
“Applied Groovy,” leads you through places where the power of Groovy is put into action.