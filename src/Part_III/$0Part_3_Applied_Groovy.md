# Part 3. Applied Groovy

#### We build too many walls and not enough bridges

<b>Isaac Newton</b>

In the course of this book, you’ve seen a large portion of Groovyland. Part 1 introduced you to the Groovy language,
datatypes, operators, control structures, and even the Meta Object Protocol. Part 2 led you through the Groovy library,
showing builders, templates, numerous JDK enhancements, working with databases, and XML support. Your backpack is
filled with valuable knowledge that waits to be brought to new horizons.

Part 3 gives you guidance on how to best apply your knowledge with other tools, frameworks, and libraries that embrace 
Groovy.

It starts with unit testing in chapter 17, an activity that no self-respecting professional developer can work without. 
With a clever mix of the Groovy wisdom you’ve already acquired and a bit of guidance through Groovy’s excellent testing 
support, you’ll appreciate unit testing as another strength of Groovy.

Chapter 18 prepares you for the to-be-expected multicore era and enables you to take full advantage of all the many 
processing cores that your machine is likely to have.

Chapter 19 gives you the power of designing your own language so that business aspects can be expressed in the jargon 
of their domain. You will become the master of domain-specific languages (DSLs).

Chapter 20 comes as a bonus for all the diligent readers who held out until the very end. You will be reimbursed with 
a sneak peek into a series of tools, libraries, and frameworks that help you with tasks that are as diverse as writing 
web application, desktop applications, automating Windows, using quality analysis tools, designing by contract, and 
much more. It’s a quick but broad overview to spark your interest in learning more about these projects. We hope you 
take it as your springboard to dive into the Groovy ocean.